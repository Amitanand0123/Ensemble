version: '3.8'

services:
  mongo:  # This defines a service named mongo in your multi-container Docker application.The name mongo is used to refer to this service in Docker’s internal DNS (e.g., mongodb://mongo:27017 from another container).
    image: mongo:latest  # Uses the official MongoDB image from Docker Hub.
    container_name: mongo_db  # Assigns a custom name to the container (mongo_db) instead of Docker’s autogenerated one. 
    ports:
      - '27017:27017'  # Exposes container’s internal port 27017 (MongoDB default) to host machine’s port 27017.
    volumes:
      - mongodata:/data/db  # Mounts a named volume called mongodata to /data/db inside the container. This is MongoDB’s data directory—ensures data is persisted even if the container stops or is deleted.Named volumes are managed by Docker and live outside the container's lifecycle.
    networks:
      - app-network # Connects this service to a user-defined bridge network called app-network. Enables other services (like backend) to reach Mongo via its service name (mongo) instead of using IP addresses. Required for inter-container communication.
    restart: unless-stopped  # Tells Docker to automatically restart this container if it crashes or Docker restarts. It will not restart if you manually stop it (docker stop mongo_db). Useful in production/dev servers to maintain availability.

  backend:  # This defines a service named backend. This name is how other services (like frontend) refer to it in the internal Docker network, e.g., http://backend:5000.
    build:  # This tells Docker Compose how to build the Docker image for the backend instead of pulling it from Docker Hub.
      context: .  # Sets the build context to the current directory (.). Everything inside this folder becomes available to the Dockerfile during build (especially needed for COPY commands).Example: If you're in the root of your project and backend folder is inside, this lets Docker access both backend/ and frontend/.
      dockerfile: backend/Dockerfile  # Specifies the exact path to the Dockerfile for the backend.Without this, Docker would expect a file named Dockerfile in the root of the context (i.e., ./Dockerfile), which is often not ideal for multi-service projects.Here, it tells Docker to use ./backend/Dockerfile to build the backend image.
    container_name: backend_app  # This explicitly names the container as backend_app.Without this, Docker would assign a name like yourfoldername_backend_1.Easier referencing (docker logs backend_app, etc.)
    ports:
      - '5000:5000'  # Maps port 5000 on your host machine to port 5000 inside the container.Allows you to access the backend running inside Docker via http://localhost:5000
    volumes:
      - ./backend:/usr/src/app/backend  # Mounts the ./backend directory from your host machine into /usr/src/app/backend inside the container. Any code change on your machine is instantly reflected inside the container (hot reload).
      - /usr/src/app/backend/node_modules  # This is an anonymous volume that prevents the node_modules folder inside the container from being overwritten by the blank node_modules from the host (which doesn't exist on host). Docker uses this to persist container-installed dependencies separately, so they aren't erased by the bind mount above.You get local live-reloading from ./backend
    env_file:
      - ./backend/.env  # Loads environment variables from the .env file located in the ./backend directory.Useful for storing secrets, DB credentials, and other configs.These variables are injected into the container and can be accessed via process.env
    environment:  # This section defines environment variables directly in the Compose file. These can override the values in .env.
      MONGO_URI: mongodb://mongo:27017/collabstack?directConnection=true&serverSelectionTimeoutMS=2000  # mongo here refers to the mongo service name from the same Docker network, which Docker resolves to the container's internal IP.
      NODE_ENV: development
      FRONTEND_URL: http://localhost:5173  # Used to tell the backend where the frontend is hosted (important for CORS, redirects, emails, etc.).
      BACKEND_URL: http://localhost:5000
    depends_on:
      mongo:  # Don't start the backend container until the mongo container has started.
        condition: service_started  # The condition: service_started ensures the container is at least running (but not necessarily ready to accept connections).
    networks:
      - app-network  # his attaches the service (backend) to the app-network bridge network.
    restart: unless-stopped  # Always restart the container unless it was explicitly stopped by the user.
  
  frontend:
    build:
      context: .
      dockerfile: frontend/Dockerfile
      args:
        VITE_API_BASE_URL: http://localhost:5000
        VITE_RAZORPAY_KEY_ID: ${VITE_RAZORPAY_KEY_ID:-rzp_test_wtJkeFcKcQTB78}
    container_name: frontend_app
    ports:
      - '5173:80'  # Maps port 80 inside the container (Nginx serving your built frontend) to port 5173 on your host machine.
    depends_on:
      - backend
    networks:
      - app-network  # Connects the frontend container to the app-network, allowing it to communicate with other services like backend or mongo via internal Docker DNS names (e.g., http://backend:5000).
    restart: unless-stopped

networks:  # This key declares the networks available to your Docker Compose services.
  app-network:  # This is the name of your custom network. It's the same name you reference under networks: in each service (e.g., frontend, backend, mongo).
    driver: bridge  # Specifies the type of network to create. In this case, it's a bridge network, which is:The default network type for containers on the same host.

volumes:
  mongodata: